Object-oriented design models the world as a series of messagese that pass betweeen objects.

Getting a message to the correct target requires that the sender know something about the receiver. This creates a dependency. OOD is about managing dependencies in such a way to make objects tolerate change well; arranging code so that it is easy to change.

Agile guarantees change (pgs 8-9).


We can solve problems using principles and patterns.

Principles:
  SOLID
    Single-responsibility
    Open-closed
    Liskov substitution
    Interface segregation
    Dependency inversion
  DRY
    Don't Repeat Yourself
  LoD
    Law of Demeter
  TRUE
    Transparent
      consequences of change should be obvious
    Reasonable
      difficulty of change proportional to its size
    Usable
      Reausable, really
    Exemplary
      Encourages the above qualities for future users

Patterns:
  Check out the Gang of Four's "Design Patterns" to learn about patterns.


Procedural languages have data types and distinct behaviors
Object-oriented languages combine data and behavior in objects.
A class-based OO language allows you to create classes, which are blueprints to create identical objects. A class defines methods (behavior) and attributes (data).
On class can instantiate (create) multiple instances of an object. Each object implements the same methods and has the same attribute names.


Single-responsibility:
Ask your classes questions about each method and variable that is public:
  Please, Mr. <Class>, what is your <method>?
  Please, Mr. <Class>, what is your <attribute>?
You should be able to describe your class in one sentance without using the word 'and'. This is called cohesion.
Methods should have a single responsibility, too.

Depend on behavior, not data.
  Data is referenced in multiple places. Behavior is defined once. Therefore behavior is easier to change.
  In practice, hide instance variables in accessor methods!
